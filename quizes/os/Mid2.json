[
  {
    "id": 1,
    "text": "A semaphore _____________________.",
    "options": [
      "can not be more than zero",
      "can not drop below zero",
      "can not be more than one",
      "can not drop below one"
    ],
    "correctAnswer": 1,
    "explanation": "A semaphore cannot drop below zero. When a process tries to perform a wait() operation on a semaphore with value 0, the process is blocked until another process performs a signal() operation to increment the semaphore value."
  },
  {
    "id": 2,
    "text": "Thread-specific data is data that __________.",
    "options": [
      "is copied and not shared with the parent process",
      "is not associated with any process",
      "is generated by the thread independent of the thread's process",
      "has been modified by the thread, but not yet updated to the parent process"
    ],
    "correctAnswer": 0,
    "explanation": "Thread-specific data (thread-local storage) is data that is private to each thread - copied and not shared with other threads or the parent process. Each thread has its own copy of this data, preventing interference between threads."
  },
  {
    "id": 3,
    "text": "When a user program performs a system call, it must first put the system call arguments onto the kernel stack and then run a special instruction to switch to kernel mode.",
    "options": [
      "True",
      "False",
      "Only for privileged system calls",
      "Only for I/O operations"
    ],
    "correctAnswer": 1,
    "explanation": "False. When a user program performs a system call, arguments are typically placed on the user stack or in registers, not the kernel stack. The system call mechanism (trap instruction) handles the mode switch and argument transfer to kernel space."
  },
  {
    "id": 4,
    "text": "Microkernels use _____ for communication.",
    "options": [
      "message passing",
      "virtualization",
      "shared memory",
      "system calls"
    ],
    "correctAnswer": 0,
    "explanation": "Microkernels rely heavily on message passing for communication between the minimal kernel and user-space services. Since most OS services run outside the kernel, message passing provides the primary inter-process communication mechanism."
  },
  {
    "id": 5,
    "text": "Which statement about scheduling algorithms is most comprehensive?",
    "options": [
      "Only shortest remaining time first scheduling may cause starvation",
      "Only preemptive scheduling may cause starvation",
      "Only round robin is better than FCFS in terms of response time",
      "Shortest remaining time first scheduling may cause starvation, preemptive scheduling may cause starvation, and round robin is better than FCFS in terms of response time"
    ],
    "correctAnswer": 3,
    "explanation": "All three statements are true: SRT can cause starvation of long processes when short processes keep arriving, preemptive scheduling can cause starvation if high-priority processes continuously preempt lower-priority ones, and round robin provides better response time than FCFS by giving each process a time slice."
  },
  {
    "id": 6,
    "text": "A microkernel is a kernel ____.",
    "options": [
      "containing many components that are optimized to reduce resident memory size",
      "that is stripped of all nonessential components",
      "that is compiled to produce the smallest size possible when stored to disk",
      "that is compressed before loading in order to reduce its resident memory size"
    ],
    "correctAnswer": 1,
    "explanation": "A microkernel is minimalist by design, containing only the most essential services (process management, memory management, IPC). All other services like file systems, device drivers, and networking run as user-space processes."
  },
  {
    "id": 7,
    "text": "In multithreaded programs, the kernel informs an application about certain events using a procedure known as a(n) ____.",
    "options": [
      "upcall",
      "signal",
      "event handler",
      "pool"
    ],
    "correctAnswer": 0,
    "explanation": "An upcall is a mechanism where the kernel notifies user-level thread libraries about events (like thread blocking on I/O) so the library can make appropriate scheduling decisions. This is particularly important in hybrid threading models."
  },
  {
    "id": 8,
    "text": "System calls can be run in either user mode or kernel mode.",
    "options": [
      "True",
      "False",
      "Only for file operations",
      "Only for memory management"
    ],
    "correctAnswer": 1,
    "explanation": "False. System calls must be executed in kernel mode to access protected system resources. The system call mechanism automatically switches from user mode to kernel mode when invoked, and returns to user mode when completed."
  },
  {
    "id": 9,
    "text": "A ________ provides an API for creating and managing threads.",
    "options": [
      "thread library",
      "multicore system",
      "multithreading model",
      "set of system calls"
    ],
    "correctAnswer": 0,
    "explanation": "A thread library provides the Application Programming Interface (API) for creating and managing threads. Examples include POSIX Pthreads, Windows threads, and Java threads. These libraries abstract the underlying threading implementation."
  },
  {
    "id": 10,
    "text": "What is the primary characteristic of user level threads?",
    "options": [
      "are managed by a thread library",
      "are scheduled by the operating system",
      "must ultimately be mapped to an associated kernel-level thread",
      "require kernel mode privileges to create"
    ],
    "correctAnswer": 0,
    "explanation": "User-level threads are primarily managed by a thread library in user space. The operating system kernel is unaware of their existence and sees only the single process. All thread operations are handled by the thread library."
  },
  {
    "id": 11,
    "text": "When an external device becomes ready to be serviced by the processor the device sends a(n) _________ signal to the processor.",
    "options": [
      "interrupt",
      "halt",
      "handler",
      "access"
    ],
    "correctAnswer": 0,
    "explanation": "An interrupt is a signal sent by an external device to the processor to indicate that it needs attention or service. This allows the processor to respond to I/O events asynchronously without constantly polling devices."
  },
  {
    "id": 12,
    "text": "_____ provide(s) an interface to the services provided by an operating system.",
    "options": [
      "System calls",
      "Communication",
      "Shared memory",
      "Simulators"
    ],
    "correctAnswer": 0,
    "explanation": "System calls provide the programmatic interface between user applications and the operating system kernel. They allow programs to request services like file operations, process management, and device access from the OS."
  },
  {
    "id": 13,
    "text": "A __________ is an entity corresponding to a user job or application that owns resources such as memory and open files.",
    "options": [
      "thread",
      "task",
      "token",
      "process"
    ],
    "correctAnswer": 3,
    "explanation": "A process is a program in execution that owns system resources including memory space, file handles, and other system objects. It represents a running application or job and serves as the unit of resource allocation in most operating systems."
  },
  {
    "id": 14,
    "text": "Which of the following instructions should definitely be privileged and restricted to kernel mode?",
    "options": [
      "Read the clock",
      "Issue a trap instruction",
      "Turn off interrupts",
      "Switch from user to kernel mode"
    ],
    "correctAnswer": 2,
    "explanation": "Turning off interrupts should be a privileged instruction because it can disable the system's ability to respond to critical events and could be used maliciously to hang the system. Reading the clock and issuing traps are typically allowed in user mode, while user-to-kernel switching is handled automatically by the system."
  },
  {
    "id": 15,
    "text": "Whenever the CPU becomes idle, the operating system must select one of the processes in the _____________ queue to be executed.",
    "options": [
      "process",
      "execution",
      "waiting",
      "ready"
    ],
    "correctAnswer": 3,
    "explanation": "The ready queue contains processes that are prepared to execute and are waiting for CPU allocation. When the CPU becomes idle, the scheduler selects a process from the ready queue based on the scheduling algorithm being used."
  },
  {
    "id": 16,
    "text": "_____ is not one of the major categories of system calls.",
    "options": [
      "Security",
      "Communications",
      "Protection",
      "Process control"
    ],
    "correctAnswer": 0,
    "explanation": "Security is not typically listed as a major category of system calls. The main categories are: Process control, File management, Device management, Information maintenance, Communications, and Protection. Security is usually considered part of protection."
  },
  {
    "id": 17,
    "text": "If a process is executing in its critical section, no other process can be executing in their critical section. This principle is called:",
    "options": [
      "Mutual Exclusion",
      "Race Condition",
      "Deadlock Prevention",
      "Starvation Avoidance"
    ],
    "correctAnswer": 0,
    "explanation": "Mutual Exclusion is the principle that ensures only one process can execute in its critical section at a time, preventing concurrent access to shared resources that could lead to inconsistent states."
  },
  {
    "id": 18,
    "text": "The problem encountered when a process is perpetually denied the necessary resources is called:",
    "options": [
      "Starvation",
      "Circular Wait",
      "Preemption",
      "Deadlock"
    ],
    "correctAnswer": 0,
    "explanation": "Starvation occurs when a process is indefinitely denied necessary resources, often due to unfair scheduling policies or resource allocation schemes that consistently favor other processes over the starving process."
  },
  {
    "id": 19,
    "text": "The circular wait condition can be prevented by:",
    "options": [
      "defining a circular order of requests",
      "maintaining a linear order of request types",
      "defining a linear order of resource types",
      "none of these"
    ],
    "correctAnswer": 2,
    "explanation": "Circular wait can be prevented by defining a linear (total) ordering of resource types and requiring that processes request resources in increasing order. This prevents the formation of circular dependency chains that lead to deadlock."
  },
  {
    "id": 20,
    "text": "Which of the following is true regarding the relationship between processes and threads:",
    "options": [
      "It takes less time to switch between two different processes than to switch between two threads within the same process",
      "It takes less time to terminate a process than a thread",
      "It takes far less time to create a new thread in an existing process than to create a new process",
      "Process and thread operations take the same amount of time"
    ],
    "correctAnswer": 2,
    "explanation": "Creating a thread within an existing process is much faster than creating a new process because threads share the process's address space and resources. Process switching and termination are generally more expensive than thread operations due to the additional overhead of managing separate address spaces."
  }
]