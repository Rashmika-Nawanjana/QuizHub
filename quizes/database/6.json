[
  {
    "id": "q1",
    "text": "When combining the instructor and department schemas into inst_dept, what problem arises?",
    "options": [
      "Loss of data integrity",
      "Possible repetition of information",
      "Violation of referential constraints",
      "Increased storage efficiency"
    ],
    "correctAnswer": 1,
    "explanation": "Combining schemas can result in possible repetition of information, as shown in the inst_dept example where department information may be repeated for each instructor."
  },
  {
    "id": "q58",
    "text": "Which of the following is an example of bad database design that normalization doesn't catch?",
    "options": [
      "Creating separate tables for each year (earnings_2004, earnings_2005, etc.)",
      "Having non-atomic attributes",
      "Partial functional dependencies",
      "Transitive dependencies"
    ],
    "correctAnswer": 0,
    "explanation": "Creating separate tables for different years is poor design that makes querying across years difficult, even though each table might be in BCNF."
  },
  {
    "id": "q59",
    "text": "Temporal data modeling adds complexity because:",
    "options": [
      "It requires more storage space",
      "Traditional functional dependencies may not hold over time",
      "It violates First Normal Form",
      "It cannot be normalized"
    ],
    "correctAnswer": 1,
    "explanation": "Temporal data causes traditional functional dependencies like ID → address not to hold because addresses change over time."
  },
  {
    "id": "q60",
    "text": "A temporal functional dependency X →T Y differs from regular functional dependencies because:",
    "options": [
      "It holds across all time periods",
      "It holds on all snapshots for all legal instances",
      "It only applies to current data",
      "It ignores time considerations"
    ],
    "correctAnswer": 1,
    "explanation": "A temporal functional dependency X →T Y holds on schema R if the functional dependency X → Y holds on all snapshots for all legal instances r(R)."
  },

  {
    "id": "q2",
    "text": "In the example combining sec_class and section relations, why is there no repetition?",
    "options": [
      "The relations have no common attributes",
      "Both relations are already normalized",
      "The combined relation maintains a one-to-one relationship",
      "Foreign key constraints prevent repetition"
    ],
    "correctAnswer": 2,
    "explanation": "There is no repetition because the relationship between sec_class and section maintains a one-to-one correspondence."
  },
  {
    "id": "q3",
    "text": "A functional dependency dept_name → building, budget indicates that:",
    "options": [
      "dept_name is always a candidate key",
      "If there were a schema with these attributes, dept_name would be a candidate key",
      "Building and budget are always dependent on dept_name",
      "The schema must be decomposed immediately"
    ],
    "correctAnswer": 1,
    "explanation": "The functional dependency is written as a rule indicating that if there were a schema with these attributes, dept_name would be a candidate key."
  },
  {
    "id": "q4",
    "text": "What makes the employee decomposition into employee1(ID, name) and employee2(name, street, city, salary) lossy?",
    "options": [
      "The relations have different primary keys",
      "Name is not a unique identifier",
      "Cannot reconstruct the original employee relation",
      "There are too many attributes in employee2"
    ],
    "correctAnswer": 2,
    "explanation": "This is a lossy decomposition because we cannot reconstruct the original employee relation - multiple employees might have the same name."
  },
  {
    "id": "q5",
    "text": "In a lossless-join decomposition of R = (A, B, C) into R1 = (A, B) and R2 = (B, C), what is the key requirement?",
    "options": [
      "A must be a primary key",
      "B must be a common attribute",
      "The join R1 ⋈ R2 = R",
      "C must be functionally dependent on A"
    ],
    "correctAnswer": 2,
    "explanation": "For a lossless-join decomposition, the natural join of R1 and R2 must equal the original relation R."
  },
  {
    "id": "q6",
    "text": "A domain is atomic if:",
    "options": [
      "It contains only numeric values",
      "Its elements are considered to be indivisible units",
      "It has no null values",
      "It is a primary key domain"
    ],
    "correctAnswer": 1,
    "explanation": "An atomic domain means its elements are considered to be indivisible units, which is a requirement for First Normal Form."
  },
  {
    "id": "q7",
    "text": "Which of the following is an example of a non-atomic domain?",
    "options": [
      "Integer values",
      "Single character strings",
      "Set of names as a single attribute",
      "Date values"
    ],
    "correctAnswer": 2,
    "explanation": "A set of names stored as a single attribute is non-atomic because it can be broken down into individual names."
  },
  {
    "id": "q8",
    "text": "Why is using identification numbers like CS101 that can be broken into parts problematic for atomicity?",
    "options": [
      "They are too long",
      "They violate First Normal Form if parts are extracted",
      "They cannot be indexed efficiently",
      "They are not unique"
    ],
    "correctAnswer": 1,
    "explanation": "If parts of CS101 are extracted (like 'CS' for department), it violates atomicity and leads to encoding information in application programs rather than the database."
  },
  {
    "id": "q9",
    "text": "A relational schema R is in First Normal Form if:",
    "options": [
      "All attributes are atomic",
      "It has no partial dependencies",
      "It has a primary key",
      "All non-key attributes are fully dependent on the primary key"
    ],
    "correctAnswer": 0,
    "explanation": "First Normal Form requires that the domains of all attributes of R are atomic."
  },
  {
    "id": "q10",
    "text": "What does a functional dependency α → β mean?",
    "options": [
      "α and β are both candidate keys",
      "β determines α uniquely",
      "α determines β uniquely",
      "α and β are independent"
    ],
    "correctAnswer": 2,
    "explanation": "A functional dependency α → β means that α determines β uniquely - whenever two tuples agree on α, they must also agree on β."
  },
  {
    "id": "q11",
    "text": "In the relation r(A,B) with tuples (1,4), (1,5), (3,7), which functional dependency holds?",
    "options": [
      "A → B",
      "B → A",
      "Both A → B and B → A",
      "Neither A → B nor B → A"
    ],
    "correctAnswer": 1,
    "explanation": "B → A holds because each B value uniquely determines an A value, but A → B does not hold because A=1 maps to both B=4 and B=5."
  },
  {
    "id": "q12",
    "text": "K is a superkey for relation schema R if and only if:",
    "options": [
      "K is minimal",
      "K → R",
      "K is unique",
      "K contains all attributes"
    ],
    "correctAnswer": 1,
    "explanation": "K is a superkey if and only if K → R, meaning K functionally determines all attributes in R."
  },
  {
    "id": "q13",
    "text": "A candidate key differs from a superkey in that:",
    "options": [
      "It's always smaller",
      "It's minimal - no subset of it is also a superkey",
      "It cannot have null values",
      "It must be a single attribute"
    ],
    "correctAnswer": 1,
    "explanation": "A candidate key is a minimal superkey - no proper subset of it is also a superkey."
  },
  {
    "id": "q14",
    "text": "A functional dependency α → β is trivial if:",
    "options": [
      "α is a candidate key",
      "β ⊆ α",
      "α and β are disjoint",
      "β is a single attribute"
    ],
    "correctAnswer": 1,
    "explanation": "A functional dependency is trivial if β ⊆ α, meaning it's satisfied by all instances of a relation."
  },
  {
    "id": "q15",
    "text": "The closure of a set F of functional dependencies (F⁺) is:",
    "options": [
      "The minimal set equivalent to F",
      "The set of all functional dependencies logically implied by F",
      "The set of candidate keys derivable from F",
      "The union of F with its complement"
    ],
    "correctAnswer": 1,
    "explanation": "F⁺ is the set of all functional dependencies that are logically implied by F."
  },
  {
    "id": "q16",
    "text": "Which of the following is Armstrong's reflexivity axiom?",
    "options": [
      "if α → β, then γα → γβ",
      "if α → β and β → γ, then α → γ",
      "if β ⊆ α, then α → β",
      "if α → β and α → γ, then α → βγ"
    ],
    "correctAnswer": 2,
    "explanation": "The reflexivity axiom states that if β ⊆ α, then α → β."
  },
  {
    "id": "q17",
    "text": "Armstrong's augmentation rule states that:",
    "options": [
      "if α → β, then γα → γβ",
      "if β ⊆ α, then α → β",
      "if α → β and β → γ, then α → γ",
      "if α → βγ, then α → β"
    ],
    "correctAnswer": 0,
    "explanation": "The augmentation rule states that if α → β, then γα → γβ (adding the same attributes to both sides)."
  },
  {
    "id": "q18",
    "text": "The transitivity rule in Armstrong's axioms is:",
    "options": [
      "if α → β, then γα → γβ",
      "if α → β and β → γ, then α → γ",
      "if β ⊆ α, then α → β",
      "if α → β and α → γ, then α → βγ"
    ],
    "correctAnswer": 1,
    "explanation": "The transitivity rule states that if α → β and β → γ, then α → γ."
  },
  {
    "id": "q19",
    "text": "Given F = {A → B, A → C, CG → H, CG → I, B → H}, which of the following is in F⁺?",
    "options": [
      "A → H",
      "AG → I",
      "CG → HI",
      "All of the above"
    ],
    "correctAnswer": 3,
    "explanation": "All are in F⁺: A → H (by transitivity), AG → I (by augmentation and transitivity), and CG → HI (by union rule)."
  },
  {
    "id": "q20",
    "text": "The attribute closure α⁺ under F is:",
    "options": [
      "The set of attributes that α functionally determines",
      "The minimal set of attributes equivalent to α",
      "The set of all candidate keys containing α",
      "The complement of α in the relation schema"
    ],
    "correctAnswer": 0,
    "explanation": "The attribute closure α⁺ is the set of attributes that are functionally determined by α under F."
  },
  {
    "id": "q21",
    "text": "To test if α is a superkey, we:",
    "options": [
      "Check if α is minimal",
      "Compute α⁺ and check if it contains all attributes of R",
      "Check if α → R is in F",
      "Verify that α has no subsets"
    ],
    "correctAnswer": 1,
    "explanation": "To test if α is a superkey, we compute α⁺ and check if it contains all attributes of R."
  },
  {
    "id": "q22",
    "text": "To check if a functional dependency α → β holds, we:",
    "options": [
      "Compute α⁺ and check if β ⊆ α⁺",
      "Compute β⁺ and check if α ⊆ β⁺",
      "Check if α and β are disjoint",
      "Verify that α is a candidate key"
    ],
    "correctAnswer": 0,
    "explanation": "To check if α → β holds, we compute α⁺ and check if β ⊆ α⁺."
  },
  {
    "id": "q23",
    "text": "In the example with R = (A,B,C,G,H,I) and given functional dependencies, what is (AG)⁺?",
    "options": [
      "AG",
      "ABCG",
      "ABCGH",
      "ABCGHI"
    ],
    "correctAnswer": 3,
    "explanation": "Following the attribute closure algorithm: (AG)⁺ = ABCGHI, which means AG is a superkey since it determines all attributes."
  },
  {
    "id": "q24",
    "text": "A canonical cover Fc for F is characterized by:",
    "options": [
      "F and Fc are logically equivalent, Fc has no extraneous attributes, each LHS in Fc is unique",
      "Fc ⊆ F and Fc has minimal size",
      "Fc contains only candidate keys",
      "Fc is the closure of F"
    ],
    "correctAnswer": 0,
    "explanation": "A canonical cover is logically equivalent to F, contains no extraneous attributes, and each left-hand side appears only once."
  },
  {
    "id": "q25",
    "text": "An attribute A is extraneous in α → β if A ∈ α and:",
    "options": [
      "A is also in β",
      "F logically implies (F - {α → β}) ∪ {(α - A) → β}",
      "A is a candidate key",
      "A appears in multiple dependencies"
    ],
    "correctAnswer": 1,
    "explanation": "A is extraneous in α if removing it from α doesn't change the closure of functional dependencies."
  },
  {
    "id": "q26",
    "text": "A relation schema R is in BCNF if for all functional dependencies α → β in F⁺:",
    "options": [
      "α is always a candidate key",
      "β ⊆ α (trivial) or α is a superkey for R",
      "α and β are disjoint",
      "β is a single attribute"
    ],
    "correctAnswer": 1,
    "explanation": "BCNF requires that for every functional dependency, either it's trivial (β ⊆ α) or α is a superkey."
  },
  {
    "id": "q27",
    "text": "Why is instr_dept(ID, name, salary, dept_name, building, budget) not in BCNF?",
    "options": [
      "It has too many attributes",
      "dept_name → building, budget holds but dept_name is not a superkey",
      "ID is not a proper candidate key",
      "There are partial dependencies"
    ],
    "correctAnswer": 1,
    "explanation": "The relation violates BCNF because dept_name → building, budget holds but dept_name is not a superkey."
  },
  {
    "id": "q28",
    "text": "When decomposing a schema R with violation α → β into BCNF, we create:",
    "options": [
      "(αβ) and (R - β)",
      "(α ∪ β) and (R - (β - α))",
      "(α) and (β)",
      "(R - α) and (αβ)"
    ],
    "correctAnswer": 1,
    "explanation": "We decompose into (α ∪ β) and (R - (β - α)) to ensure lossless decomposition while eliminating the BCNF violation."
  },
  {
    "id": "q29",
    "text": "BCNF decomposition is always:",
    "options": [
      "Dependency preserving",
      "Lossless-join",
      "Both lossless-join and dependency preserving",
      "Neither lossless-join nor dependency preserving"
    ],
    "correctAnswer": 1,
    "explanation": "BCNF decomposition is always lossless-join, but it may not always be dependency preserving."
  },
  {
    "id": "q30",
    "text": "Third Normal Form (3NF) is a weaker condition than BCNF because it allows:",
    "options": [
      "Non-atomic attributes",
      "Partial dependencies",
      "Some non-key attributes in β when α → β violates BCNF, if each attribute in β - α is in a candidate key",
      "Transitive dependencies"
    ],
    "correctAnswer": 2,
    "explanation": "3NF allows violations of BCNF if each attribute in β - α is contained in some candidate key of R."
  },
  {
    "id": "q31",
    "text": "A relation schema R is in 3NF if for all α → β in F⁺:",
    "options": [
      "α is always a superkey",
      "β ⊆ α (trivial), or α is a superkey, or each attribute in β - α is in a candidate key",
      "There are no transitive dependencies",
      "All attributes are atomic"
    ],
    "correctAnswer": 1,
    "explanation": "3NF allows the additional condition that each attribute in β - α is contained in a candidate key for R."
  },
  {
    "id": "q32",
    "text": "Why might we prefer 3NF over BCNF in some cases?",
    "options": [
      "3NF eliminates more redundancy",
      "3NF is always lossless and dependency preserving",
      "3NF is easier to compute",
      "3NF allows null values"
    ],
    "correctAnswer": 1,
    "explanation": "We might prefer 3NF because it's always possible to achieve both lossless-join and dependency preservation, unlike BCNF."
  },
  {
    "id": "q33",
    "text": "In the inst_info(ID, child_name, phone) example, why is the BCNF schema still problematic?",
    "options": [
      "It's not actually in BCNF",
      "It has insertion anomalies despite being in BCNF",
      "It violates referential integrity",
      "It has too many attributes"
    ],
    "correctAnswer": 1,
    "explanation": "Even though it's in BCNF, the schema has insertion anomalies - adding a phone number requires adding multiple tuples."
  },
  {
    "id": "q34",
    "text": "The inst_info example suggests the need for:",
    "options": [
      "Better BCNF decomposition",
      "Returning to 3NF",
      "Higher normal forms like 4NF",
      "Denormalization"
    ],
    "correctAnswer": 2,
    "explanation": "The example illustrates why we might need higher normal forms like Fourth Normal Form (4NF) to handle multivalued dependencies."
  },
  {
    "id": "q35",
    "text": "To compute the closure of a set F of functional dependencies, we repeatedly apply:",
    "options": [
      "Only Armstrong's axioms",
      "Armstrong's axioms until no new dependencies can be derived",
      "The union and decomposition rules",
      "Attribute closure algorithms"
    ],
    "correctAnswer": 1,
    "explanation": "We compute F⁺ by repeatedly applying Armstrong's axioms (reflexivity, augmentation, transitivity) until no new dependencies can be derived."
  },
  {
    "id": "q36",
    "text": "The union rule states that if α → β and α → γ hold, then:",
    "options": [
      "α → βγ holds",
      "β → γ holds",
      "αβ → γ holds",
      "α → β ∩ γ holds"
    ],
    "correctAnswer": 0,
    "explanation": "The union rule states that if α → β and α → γ, then α → βγ (combining the right-hand sides)."
  },
  {
    "id": "q37",
    "text": "The decomposition rule states that if α → βγ holds, then:",
    "options": [
      "α → β and α → γ both hold",
      "β → γ holds",
      "α → β or α → γ holds",
      "βγ → α holds"
    ],
    "correctAnswer": 0,
    "explanation": "The decomposition rule states that if α → βγ, then both α → β and α → γ hold."
  },
  {
    "id": "q38",
    "text": "In computing a canonical cover, why do we use the union rule first?",
    "options": [
      "It reduces the number of dependencies",
      "It eliminates extraneous attributes",
      "It combines dependencies with the same left-hand side",
      "It identifies candidate keys"
    ],
    "correctAnswer": 2,
    "explanation": "The union rule combines dependencies with the same left-hand side, which is required for the canonical cover property that each LHS is unique."
  },
  {
    "id": "q39",
    "text": "To test if attribute A ∈ α is extraneous in α → β, we:",
    "options": [
      "Check if A appears in β",
      "Compute (α - {A})⁺ and see if it contains β",
      "Check if A is a candidate key",
      "Verify that A → β holds"
    ],
    "correctAnswer": 1,
    "explanation": "We test if A is extraneous by computing (α - {A})⁺ and checking if it contains β - if so, A is extraneous."
  },
  {
    "id": "q40",
    "text": "A decomposition of R into R₁ and R₂ is lossless-join if:",
    "options": [
      "R₁ ∩ R₂ ≠ ∅",
      "R₁ ∩ R₂ → R₁ or R₁ ∩ R₂ → R₂",
      "R₁ ∪ R₂ = R",
      "Both conditions 2 and 3"
    ],
    "correctAnswer": 3,
    "explanation": "A decomposition is lossless-join if the intersection of schemas functionally determines at least one of the schemas, and the union covers the original schema."
  },
  {
    "id": "q41",
    "text": "In the example R = (A,B,C) with F = {A → B, B → C}, the decomposition R₁ = (A,B), R₂ = (B,C) is:",
    "options": [
      "Lossless but not dependency preserving",
      "Dependency preserving but not lossless",
      "Both lossless and dependency preserving",
      "Neither lossless nor dependency preserving"
    ],
    "correctAnswer": 2,
    "explanation": "This decomposition is both lossless (since B → BC) and dependency preserving (all original dependencies can be checked)."
  },
  {
    "id": "q42",
    "text": "A decomposition is dependency preserving if:",
    "options": [
      "All original dependencies can be checked without computing joins",
      "(F₁ ∪ F₂ ∪ ... ∪ Fₙ)⁺ = F⁺",
      "Each dependency in F appears in exactly one Fᵢ",
      "The decomposition is lossless"
    ],
    "correctAnswer": 1,
    "explanation": "A decomposition is dependency preserving if (F₁ ∪ F₂ ∪ ... ∪ Fₙ)⁺ = F⁺, meaning all original constraints can be enforced."
  },
  {
    "id": "q43",
    "text": "To test if a dependency α → β is preserved in a decomposition, we use:",
    "options": [
      "Armstrong's axioms directly",
      "Attribute closure with a specific algorithm that considers only attributes in each relation",
      "Canonical cover computation",
      "BCNF testing"
    ],
    "correctAnswer": 1,
    "explanation": "We use a specific algorithm that iteratively applies attribute closure restricted to each relation in the decomposition."
  },
  {
    "id": "q44",
    "text": "The simplified test for BCNF violations states that:",
    "options": [
      "We must check all dependencies in F⁺",
      "We only need to check dependencies in F for the original relation",
      "We only need to check candidate keys",
      "We must compute the canonical cover first"
    ],
    "correctAnswer": 1,
    "explanation": "For the original relation, it suffices to check only the dependencies in F rather than all of F⁺."
  },
  {
    "id": "q45",
    "text": "Why is the simplified BCNF test incorrect for relations in a decomposition?",
    "options": [
      "Decomposed relations have different candidate keys",
      "New functional dependencies in F⁺ may apply to the decomposed relation",
      "The original dependencies no longer hold",
      "Armstrong's axioms don't apply to decomposed relations"
    ],
    "correctAnswer": 1,
    "explanation": "In decomposed relations, dependencies in F⁺ that weren't in the original F may cause BCNF violations."
  },
  {
    "id": "q46",
    "text": "In the BCNF decomposition algorithm, when we find a violation α → β, we replace Rᵢ with:",
    "options": [
      "(α ∪ β) and (Rᵢ - β)",
      "(α ∪ β) and (Rᵢ - (β - α))",
      "(α) and (β)",
      "(Rᵢ - α) and (α ∪ β)"
    ],
    "correctAnswer": 1,
    "explanation": "We replace Rᵢ with (α ∪ β) and (Rᵢ - (β - α)) to maintain losslessness while eliminating the violation."
  },
  {
    "id": "q47",
    "text": "The BCNF decomposition algorithm guarantees:",
    "options": [
      "Each resulting relation is in BCNF and the decomposition is lossless",
      "The decomposition is dependency preserving",
      "The algorithm terminates in polynomial time",
      "All of the above"
    ],
    "correctAnswer": 0,
    "explanation": "The BCNF algorithm guarantees that each relation is in BCNF and the decomposition is lossless, but not necessarily dependency preserving."
  },
  {
    "id": "q48",
    "text": "In the class relation example with course_id → title, dept_name, credits, the first decomposition creates:",
    "options": [
      "course(course_id, title, dept_name, credits) and the remaining attributes",
      "Two relations with equal numbers of attributes",
      "A relation containing only the candidate key",
      "course(course_id, title) and dept(dept_name, credits)"
    ],
    "correctAnswer": 0,
    "explanation": "The first step creates course(course_id, title, dept_name, credits) and class-1 with the remaining attributes."
  },
  {
    "id": "q49",
    "text": "Why is it not always possible to achieve both BCNF and dependency preservation?",
    "options": [
      "BCNF is too restrictive",
      "Some dependencies inherently require joins to check",
      "The decomposition algorithm is incomplete",
      "Functional dependencies may conflict"
    ],
    "correctAnswer": 1,
    "explanation": "Some functional dependencies inherently require information from multiple relations to check, making dependency preservation impossible while maintaining BCNF."
  },
  {
    "id": "q50",
    "text": "The 3NF decomposition algorithm starts with:",
    "options": [
      "The original relation R",
      "A canonical cover Fc for F",
      "All candidate keys of R",
      "The BCNF decomposition"
    ],
    "correctAnswer": 1,
    "explanation": "The 3NF algorithm starts by computing a canonical cover Fc for the set of functional dependencies F."
  },
  {
    "id": "q51",
    "text": "In the 3NF decomposition algorithm, for each dependency α → β in Fc, we:",
    "options": [
      "Create a relation containing α ∪ β",
      "Test if it violates 3NF",
      "Check if any existing relation contains α ∪ β",
      "Decompose it further"
    ],
    "correctAnswer": 0,
    "explanation": "For each dependency α → β in Fc, we create a relation schema containing α ∪ β."
  },
  {
    "id": "q52",
    "text": "Why does the 3NF algorithm add a relation containing a candidate key?",
    "options": [
      "To ensure lossless decomposition",
      "To preserve all dependencies",
      "To maintain 3NF property",
      "To minimize the number of relations"
    ],
    "correctAnswer": 0,
    "explanation": "Adding a candidate key ensures that the decomposition is lossless-join."
  },
  {
    "id": "q53",
    "text": "The 3NF decomposition algorithm guarantees:",
    "options": [
      "Each relation is in 3NF only",
      "Lossless decomposition only",
      "Dependency preservation only",
      "Each relation is in 3NF, and the decomposition is both lossless and dependency preserving"
    ],
    "correctAnswer": 3,
    "explanation": "The 3NF algorithm guarantees all three properties: each relation is in 3NF, the decomposition is lossless, and it preserves dependencies."
  },
  {
    "id": "q54",
    "text": "Testing for 3NF is:",
    "options": [
      "Polynomial time",
      "NP-hard",
      "Exponential time",
      "Linear time"
    ],
    "correctAnswer": 1,
    "explanation": "Testing for 3NF has been shown to be NP-hard, unlike decomposition into 3NF which can be done in polynomial time."
  },
  {
    "id": "q55",
    "text": "In the cust_banker_branch example, after computing the canonical cover, branch_name is found to be:",
    "options": [
      "A candidate key",
      "Extraneous in the first dependency",
      "Required for lossless decomposition",
      "Part of multiple dependencies"
    ],
    "correctAnswer": 1,
    "explanation": "In the canonical cover computation, branch_name is found to be extraneous in the right-hand side of the first dependency."
  },
  {
    "id": "q56",
    "text": "Denormalization for performance involves:",
    "options": [
      "Always choosing BCNF over 3NF",
      "Using non-normalized schemas to avoid joins",
      "Eliminating all functional dependencies",
      "Creating more relations"
    ],
    "correctAnswer": 1,
    "explanation": "Denormalization uses non-normalized schemas to avoid expensive joins, trading storage space and update complexity for query performance."
  },
  {
    "id": "q57",
    "text": "Using materialized views for denormalization provides:",
    "options": [
      "The same benefits as denormalization without extra programming work",
      "Better performance than regular denormalization",
      "Automatic dependency preservation",
      "Guaranteed consistency"
    ],
    "correctAnswer": 0,
    "explanation": "Materialized views provide the performance benefits of denormalization while avoiding the extra programming work and potential errors."
  }
]